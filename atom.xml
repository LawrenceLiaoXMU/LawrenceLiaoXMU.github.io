<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Liao&#39;s Blog：一个小白的计算机-数字媒体技术学习记录</title>
  
  <subtitle>计算机学习记录</subtitle>
  <link href="https://lawrenceliaoxmu.github.io/atom.xml" rel="self"/>
  
  <link href="https://lawrenceliaoxmu.github.io/"/>
  <updated>2023-08-09T08:40:11.069Z</updated>
  <id>https://lawrenceliaoxmu.github.io/</id>
  
  <author>
    <name>Lawrence Liao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《计算机科学速成课》第七、八、九课自学笔记：有关中央处理器（CPU）</title>
    <link href="https://lawrenceliaoxmu.github.io/2023/08/07/%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%88CPU%EF%BC%89/"/>
    <id>https://lawrenceliaoxmu.github.io/2023/08/07/%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%88CPU%EF%BC%89/</id>
    <published>2023-08-07T14:16:58.000Z</published>
    <updated>2023-08-09T08:40:11.069Z</updated>
    
    <content type="html"><![CDATA[<p>因为在课程中第七、八、九课联系较紧密，故在同一文档中梳理。<br>笔记结合课程、上网查询、个人理解整理，如有错误，恳请指正。</p><h1 id="第七课-中央处理器基础知识"><a href="#第七课-中央处理器基础知识" class="headerlink" title="第七课 中央处理器基础知识"></a>第七课 中央处理器基础知识</h1><h2 id="一、简单总结"><a href="#一、简单总结" class="headerlink" title="一、简单总结"></a>一、简单总结</h2><h3 id="CPU的主要功能有：处理指令、执行操作、控制时间、处理数据"><a href="#CPU的主要功能有：处理指令、执行操作、控制时间、处理数据" class="headerlink" title="CPU的主要功能有：处理指令、执行操作、控制时间、处理数据"></a>CPU的主要功能有：处理指令、执行操作、控制时间、处理数据</h3><h3 id="CPU主要由-①运算器（计算逻辑单元ALU）②控制器（控制单元）③寄存器组-④时钟-组成-而在其中："><a href="#CPU主要由-①运算器（计算逻辑单元ALU）②控制器（控制单元）③寄存器组-④时钟-组成-而在其中：" class="headerlink" title="CPU主要由 ①运算器（计算逻辑单元ALU）②控制器（控制单元）③寄存器组 ④时钟 组成 而在其中："></a>CPU主要由 ①运算器（计算逻辑单元ALU）②控制器（控制单元）③寄存器组 ④时钟 组成 而在其中：</h3><p>①ALU主要完成处理数据的任务。<br>②控制单元包含寄存器（指令寄存器、指令地址寄存器）、指令译码器、操作控制器，主要完成上述处理指令、执行操作的任务。<br>③寄存器组用来临时存储数据和操作数据。<br>④时钟主要管理CPU执行程序的节奏 ，CPU 执行“取指令→解码→执行”中每一步的速度叫做“时钟速度”，单位赫兹Hz，表示频率，超频的概率就是从中而来的。当今很多计算机都能能够做到动态调整频率。</p><h3 id="CPU的大致过程为：取指令阶段-解码阶段-执行阶段-结束"><a href="#CPU的大致过程为：取指令阶段-解码阶段-执行阶段-结束" class="headerlink" title="CPU的大致过程为：取指令阶段-解码阶段-执行阶段-结束"></a>CPU的大致过程为：取指令阶段-解码阶段-执行阶段-结束</h3><p><img src="/images/cpu%E7%BB%84%E6%88%90.png" alt="Lena"></p><ul><li>这是图1 主要展示CPU的构成</li></ul><h2 id="二、具体步骤举例"><a href="#二、具体步骤举例" class="headerlink" title="二、具体步骤举例"></a>二、具体步骤举例</h2><ul><li><em>这里的例子仅仅是例子，指令不一定是八位</em><br><em>在例子中，指令前四位是操作码，后四位是CPU内寄存器的地址或者从RAM获取数据、向RAM输入数据的地址等等</em></li></ul><p><img src="/images/%E6%8C%87%E4%BB%A4%E5%AF%B9%E7%85%A7%E8%A1%A8.png" alt="Lena"></p><ul><li>这是图2<br><img src="/images/%E8%AE%A1%E7%AE%971.png" alt="Lena"></li><li>这是图3</li></ul><h3 id="1-取指令阶段"><a href="#1-取指令阶段" class="headerlink" title="1.取指令阶段"></a>1.取指令阶段</h3><p>在图3中我们看到，此时指令地址寄存器中的地址为0000 0010，对应的数字是2。<br>于是RAM的地址2的数据1000 0100进入到指令储存器中。</p><h3 id="2-解码阶段"><a href="#2-解码阶段" class="headerlink" title="2.解码阶段"></a>2.解码阶段</h3><p>由逻辑门组成的控制单元对指令进行解码，同时检验操作码<br><img src="/images/%E6%A3%80%E9%AA%8C%E4%B8%80%E4%B8%8B.png" alt="Lena"></p><ul><li>这是图4  主要是该部分的逻辑门组成方式（不过图中指令并不是本笔记中举出的）</li></ul><h3 id="3-执行阶段"><a href="#3-执行阶段" class="headerlink" title="3.执行阶段"></a>3.执行阶段</h3><p>根据图1，1000 0100指令前四位所代表的操作是将两个寄存器的值相加，再将结果传输进第二个寄存器当中。<br>再看后四位，0100代表的并不是RAM地址 01代表的是CPU中寄存器B，00代表的是寄存器A。</p><ul><li><em>因为00在01后面 所以实际上寄存器A代表的是指令中的“第二个寄存器”。</em></li></ul><p>所以A中的0000 0011（3）和B中的00001110（14）经过控制单元 通过ALU进行相加，ALU再将相加所得的数据返回回A。<br>这里就类似于编程当中可能会出现的A&#x3D;A+B了，如果不停止的话，这个过程会无穷无尽加下去。而在这里，控制单元会用一个寄存器暂时保存结果，关闭ALU，然后再返回值到A中。<br><img src="/images/%E8%AE%A1%E7%AE%972.png" alt="Lena"></p><ul><li>这是图5，可以看到3+14&#x3D;17 也就是A中的10001</li></ul><h3 id="4-最后地址寄存器数值-1-执行结束"><a href="#4-最后地址寄存器数值-1-执行结束" class="headerlink" title="4.最后地址寄存器数值+1 执行结束"></a>4.最后地址寄存器数值+1 执行结束</h3><h2 id="三、RAM和CPU的关系"><a href="#三、RAM和CPU的关系" class="headerlink" title="三、RAM和CPU的关系"></a>三、RAM和CPU的关系</h2><p>RAM在CPU之外，CPU 和 RAM 之间用“地址线”、“数据线”和“允许读&#x2F;写线”进行通信。</p><hr><h1 id="第八课-指令和程序"><a href="#第八课-指令和程序" class="headerlink" title="第八课 指令和程序"></a>第八课 指令和程序</h1><h2 id="一、相关概念"><a href="#一、相关概念" class="headerlink" title="一、相关概念"></a>一、相关概念</h2><p>1.指令：指示计算机要做什么的代码，有多种分类，比如数学指令、内存指令。<br>2.程序：由多条指令共组成。<br>3.指令集：记录指令名称、用法、操作码以及所需 RAM 地址位数的表格（如七-2）。</p><h2 id="二、一些基础的指令"><a href="#二、一些基础的指令" class="headerlink" title="二、一些基础的指令"></a>二、一些基础的指令</h2><p>1.LOAD指令：读取地址中的指令并存储到指定位置。<br>2.ADD指令：相加多处数据并存到指定位置（第七课笔记举的例子）。<br>3.JUMP 指令：让程序会跳转至对应的 RAM 地址读取数据。可以是无条件跳转：<br><img src="/images/%E5%BE%AA%E7%8E%AF.png" alt="Lena"></p><ul><li>这是图1，表现出编程中的循环<br>也可以进行有条件的跳转。（如 JUMP-negative，若目标值为负数才执行跳转。）<br>4.HALT指令：停止程序。</li></ul><h2 id="三、指令的发展"><a href="#三、指令的发展" class="headerlink" title="三、指令的发展"></a>三、指令的发展</h2><p>课程当中举出的指令都只有8位，能表示的内容太少，有如下两个解决方法。<br>1.最直接的是用增加指令位数，如 32 位或 64 位。<br>2.其次是采用“可变指令长度”，令不同的指令的长度不同，尽量节约位数。假设 1 个字为 16 位，如果某指令不需要操作内存，则可以省去寻址的位数。（该情况下，部分指令，如 JUMP，后面需要跟的数据称为立即值。）</p><hr><h1 id="第九课-高级CPU设计（CPU的升级）"><a href="#第九课-高级CPU设计（CPU的升级）" class="headerlink" title="第九课 高级CPU设计（CPU的升级）"></a>第九课 高级CPU设计（CPU的升级）</h1><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>早期计算机提速是通过减少晶体管切换的时间进行的（但是这种方式具有瓶颈），或者是设计专门的复杂电路进行某个操作（比如除法电路），让CPU更大更复杂，但也运行速度更快。</p><h2 id="二、通过优化单个指令流来进行改进"><a href="#二、通过优化单个指令流来进行改进" class="headerlink" title="二、通过优化单个指令流来进行改进"></a>二、通过优化单个指令流来进行改进</h2><h3 id="1-缓存的运用"><a href="#1-缓存的运用" class="headerlink" title="1.缓存的运用"></a>1.缓存的运用</h3><p>缓存是在 CPU 中的小块 RAM，用于存储批量指令。在缓存未被发明出来的时候，CPU从RAM通过总线BUS获取数据时，只能一条一条传输。但缓存发明之后，可以一次性传一批数据存放在缓存中，缓存中的数据再传给CPU的速度快很多。<br><img src="/images/91.png" alt="Lena"></p><ul><li>这是图1<br>如果想要的数据在缓存中，叫做缓存命中，反之叫做缓存未命中。缓存可以当临时空间，存一些中间值，适合长\负责的运算。<br>计算完的数据不会立马返回RAM，而是存在缓存中。缓存里的数据要对RAM里的数据进行更新，缓存里每块空间，有一个特殊标记，叫“脏位”。<br>当缓存满了，计算机会检查缓存中的脏位，如果是脏的（即缓存中的数据与RAM中的不同），便会先把被标记为脏位的数据优先写回RAM中，再传输下一批数据进缓存。</li></ul><h3 id="2-指令流水线（并行处理）"><a href="#2-指令流水线（并行处理）" class="headerlink" title="2.指令流水线（并行处理）"></a>2.指令流水线（并行处理）</h3><p>使CPU在处理指令时，不一定要完全按照串行流程，可以按照并行方式进行。例如，当此条指令正在“执行”时，可以处理下一个指令的“解码”，下下条指令的“读取”，这样可以同时利用上CPU里的所有部分。增大吞吐量<br><img src="/images/92.png" alt="Lena"></p><ul><li>这是图2，串行流程<br><img src="/images/93.png" alt="Lena"></li><li>这是图3，并流程</li><li>但这个可能会面临一些问题，比如说 ①数据可能具有依赖性：上一条指令可以会改变下一条指令的运行方式，同时进行可能导致执行时非常混乱 或者是 ②条件跳转，一般来说简单的流水线处理器，看到JUMP指令会停一会，等待条件值确定下来，条件结果出了，才能判断是否进行JUMP，这个等待会消耗很多时间。结局方案如下<br>针对问题①：可以进行对有依赖关系指令的动态排序，即“乱序执行”。<br>针对问题②：高级的流水线处理器会提前猜测哪个条件可能性大，然后提前把指令放在流水线上，这叫“推测执行”。如果猜测正确，则立即执行，错误则会清空刚才加载的指令，重新加载。为了减少清空次数，CPU开发了高级方法来猜测哪条分支更有可能，叫“分支预测”。现代计算机的猜测正确率高达90%。</li></ul><h2 id="三、多个指令流的使用"><a href="#三、多个指令流的使用" class="headerlink" title="三、多个指令流的使用"></a>三、多个指令流的使用</h2><h3 id="多核处理器"><a href="#多核处理器" class="headerlink" title="多核处理器"></a>多核处理器</h3><p>让CPU芯片具有多个独立处理的单元，同时运行多个指令流。当然，核不够时，可以用多个CPU。超级计算器神威·太湖之光，有40960个CPU，每个CPU有256个核心，总共超过1千万个核心。（强！）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因为在课程中第七、八、九课联系较紧密，故在同一文档中梳理。&lt;br&gt;笔记结合课程、上网查询、个人理解整理，如有错误，恳请指正。&lt;/p&gt;
&lt;h1 id=&quot;第七课-中央处理器基础知识&quot;&gt;&lt;a href=&quot;#第七课-中央处理器基础知识&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="自学笔记" scheme="https://lawrenceliaoxmu.github.io/categories/%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机科学速成课" scheme="https://lawrenceliaoxmu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE/"/>
    
    <category term="计算机科学导论" scheme="https://lawrenceliaoxmu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>《计算机科学速成课》第十、十一、十二课自学笔记：基础的编程</title>
    <link href="https://lawrenceliaoxmu.github.io/2023/08/07/%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9A%84%E7%BC%96%E7%A8%8B/"/>
    <id>https://lawrenceliaoxmu.github.io/2023/08/07/%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9A%84%E7%BC%96%E7%A8%8B/</id>
    <published>2023-08-07T14:16:58.000Z</published>
    <updated>2023-08-12T02:30:12.134Z</updated>
    
    <content type="html"><![CDATA[<p>因为在课程中第十、十一、十二课联系较紧密，故在同一文档中梳理。<br>笔记结合课程、上网查询、个人理解整理，如有错误，恳请指正。</p><h1 id="第十课-早期编程方式（程序如何进入计算机？）"><a href="#第十课-早期编程方式（程序如何进入计算机？）" class="headerlink" title="第十课 早期编程方式（程序如何进入计算机？）"></a>第十课 早期编程方式（程序如何进入计算机？）</h1><h2 id="一、插线编程"><a href="#一、插线编程" class="headerlink" title="一、插线编程"></a>一、插线编程</h2><h3 id="1-简单介绍"><a href="#1-简单介绍" class="headerlink" title="1.简单介绍"></a>1.简单介绍</h3><p>二十世纪时，计算机开始能够进行加减乘除等运算，甚至决定执行某指令的时间。此时，程序的正确执行需要程序员通过将插线板作为控制面板，通过对不同部分进行连线，互相穿数据和信号，世界上第一台电子计算机Eniac也是通过这种方式进行编程。</p><h3 id="2-弊端"><a href="#2-弊端" class="headerlink" title="2.弊端"></a>2.弊端</h3><p>插线板编程很复杂，运行不同程序要重新接线，更换程序需要大量时间。</p><h2 id="二、-冯诺依曼计算机"><a href="#二、-冯诺依曼计算机" class="headerlink" title="二、 冯诺依曼计算机"></a>二、 冯诺依曼计算机</h2><h3 id="1-简单介绍-1"><a href="#1-简单介绍-1" class="headerlink" title="1.简单介绍"></a>1.简单介绍</h3><p>内存的出现与发展，出现了“存储程序计算机”，能在内存里存储程和数据。其标志是一个ALU+数据寄存器（寄存器组）+指令寄存器+指令地址寄存器+内存，也就是前几集学的基本的CPU+RAM。</p><h3 id="2-弊端-1"><a href="#2-弊端-1" class="headerlink" title="2.弊端"></a>2.弊端</h3><p>那时写入程序和输出数据还是通过对穿孔纸卡进行打孔，相当于将数据放在纸卡上，如果弄乱了卡片需要大量时间来整理。（还很费纸）</p><h2 id="三、面板编程"><a href="#三、面板编程" class="headerlink" title="三、面板编程"></a>三、面板编程</h2><h3 id="1-简单介绍-2"><a href="#1-简单介绍-2" class="headerlink" title="1.简单介绍"></a>1.简单介绍</h3><p>1980年代前，出现面板编程，即用一大堆开关进行控制。通过开关控制进行二进制代码的编写，然后就可以运行程序。</p><h3 id="2-弊端（以上三个都有）"><a href="#2-弊端（以上三个都有）" class="headerlink" title="2.弊端（以上三个都有）"></a>2.弊端（以上三个都有）</h3><p>使用门槛较高，编程者需要非常了解底层硬件，比如操作码和寄存器等等。</p><hr><h1 id="第十一课-编程语言发展史（从硬件到软件）"><a href="#第十一课-编程语言发展史（从硬件到软件）" class="headerlink" title="第十一课 编程语言发展史（从硬件到软件）"></a>第十一课 编程语言发展史（从硬件到软件）</h1><ul><li>不同的语言可以只一种数据的多种表现方式。就像英语和摩斯密码，虽然二者的符号和表达不同，但是可以传达相同的信息</li></ul><h2 id="一、机器语言"><a href="#一、机器语言" class="headerlink" title="一、机器语言"></a>一、机器语言</h2><p>二进制是处理器能理解的语言，“机器语言”或者“机器码”。早期，人们会先用普通的语言表达出希望计算机进行的一步步程序（这叫做伪代码），然后根据“操作码表”将它一个个对应着转换为二进制机器码，再将其传递给计算机</p><h2 id="二、汇编语言（也是低级语言）"><a href="#二、汇编语言（也是低级语言）" class="headerlink" title="二、汇编语言（也是低级语言）"></a>二、汇编语言（也是低级语言）</h2><p>1940-1950年代，程序员开发一种新语言，更可读更高层次。每一个操作码都会分配一个简单的名字，叫“助记符”。比如代表“将A中数据存入寄存器12”的一大串二进制数字，可以被写成LOAD_A 12，通过汇编器，计算机会识别汇编语言，再将其转化为机器语言。</p><ul><li>汇编器有很多好用的功能，其中一个就是自动分析JUMP地址，程序员写程序时，只需写入可跳转的标签，汇编器就会自己跳转分析。不会因为插入指令而改变指令的顺序而导致JUMP的目标位置发生变化。<br> <img src="/images/111.png" alt="Lena"></li><li>这是图1 表现了跳转标签的使用</li></ul><h2 id="三、高级编程语言与编译器的出现"><a href="#三、高级编程语言与编译器的出现" class="headerlink" title="三、高级编程语言与编译器的出现"></a>三、高级编程语言与编译器的出现</h2><p>高级编程语言可以将原本的十几二十条指令转化为简单的一句话，使编程者不用再思考内存和寄存器位置这种底层细节。编译器就是专门把高级语言转成低级语言的工具。<br> <img src="/images/112.png" alt="Lena"></p><ul><li>这是图2<br>早期的高级编程语言有A-0语言和Fortran语言。这些语言的使用虽然会使运行速度稍稍变慢（计算机执行程序的步骤变多了），但大大提高了代码编写的速度。<br>起初的语言和编译器并未统一，大部分编程语言和编译器只能运行在一种计算机上。后来成立的了数据系统语言委员会。开发了通用编程语言Cobol，可以在不同机器上通用，做到一次编写，万处运行。</li></ul><p> <img src="https://imgse.com/i/pPupv5V" alt="图床"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因为在课程中第十、十一、十二课联系较紧密，故在同一文档中梳理。&lt;br&gt;笔记结合课程、上网查询、个人理解整理，如有错误，恳请指正。&lt;/p&gt;
&lt;h1 id=&quot;第十课-早期编程方式（程序如何进入计算机？）&quot;&gt;&lt;a href=&quot;#第十课-早期编程方式（程序如何进入计算机？）&quot; cl</summary>
      
    
    
    
    <category term="自学笔记" scheme="https://lawrenceliaoxmu.github.io/categories/%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机科学速成课" scheme="https://lawrenceliaoxmu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE/"/>
    
    <category term="计算机科学导论" scheme="https://lawrenceliaoxmu.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA/"/>
    
  </entry>
  
</feed>
